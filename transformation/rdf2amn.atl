module rdf2amn;
create OUT: AMN from IN: SW;

-- @path SW=/metamodel/SW.ecore
-- @path AMN=/metalmodel/AMN.ecore

--- Global Variables

helper def: gNamedIndividual:  Set(String) =
	Set{}
;

helper def: gParentClass: Map(String, String) = 
	Map{}
;

helper def: gClassRestriction: Map(String, OrderedSet(String)) =
	Map{}
;



rule RDF2Refinement{
	from 
		rd: SW!RDFDocument
	using {
		refName:String = rd.owlOntology->collect(c|c.shortName).first();
	}
	to 
		--- SEES
		ctxt: AMN!AbstractMachine(
			name <- 'ContextRDF'
		),
		--- REFINEMENT
		ref: AMN!Refinement(
			name <- thisModule.refinementName(refName),
			refines <- thisModule.initAMNRefines(ctxt, ref.name, rd),
			sees <- ctxt,
			sets <- thisModule.initAMNSets(rd),
			definitions <- thisModule.initAMNDefinitions(),
			abstractConstants <- thisModule.initAMNAbstractConstants(rd),
			properties <- thisModule.initAMNProperties(rd, ref.abstractConstants),
			abstractVariables <- thisModule.initAMNAbstractVariables(rd),
			invariant <- thisModule.initAMNInvariant(rd, ref.abstractVariables),
			initialization <- thisModule.initAMNInitialisation(rd),
			operations <- rd.sparql->collect(s | thisModule.resolveTemp(s, 'op'))
		)
	do {
		thisModule.debug('RDF2Refinement: done!');
	}
}

rule initAMNSets(rd: SW!RDFDocument) {
	to
		classSet: AMN!SetDecl(
			name <- 'IC',
			element <- 'Thing',
			element <- rd.owlClass->collect(c|c.shortName)
		),
		objProSet: AMN!SetDecl(
			name <- 'IP',
			element <- rd.owlObjectProperty->collect(o|o.shortName)	
		)
	do{
		Sequence{classSet,
				rd.owlDatatypeProperty->collect(o | thisModule.resolveTemp(o, 'range_set')),
				objProSet};
	}
}

rule initAMNDefinitions() {
	to
		definition: AMN!Definition(
			name <- 'STRING_TYPE',
			type <- 'seq(0..255)'
		),
		defExp: AMN!FunctionalExpression(
			sign <- 'seq',
			expression <- defVar
		),
		defVar: AMN!Variable(
			name <- '0..255'
		)
	do {
		definition;	
	}
}

rule initAMNAbstractConstants(rd: SW!RDFDocument) {
	do{
		Sequence{'IS_IP',
			rd.owlDatatypeProperty->collect(o | thisModule.ISIP_name_Range(o.range.shortName)),
			rd.owlNamedIndividual->collect(o | o.shortName)
		};
	}
}

rule initAMNProperties(rd: SW!RDFDocument, abstractConstants: Sequence(String)) {
	to
		conjProperties: AMN!Conjunction(
			predicate <- abstractConstants->select(n|not thisModule.isInstance(n))->collect(ac | thisModule.initPropertiesIRI(ac)),
			predicate <- abstractConstants->select(n|not thisModule.isInstance(n))->collect(ac | thisModule.initPropertiesFIN(ac)),
			predicate <- thisModule.initPropertiesDOM(abstractConstants->select(a|not thisModule.isInstance(a))),
			predicate <- thisModule.initPropertiesCardDOM(abstractConstants->select(a|not thisModule.isInstance(a))),
			predicate <- rd.owlNamedIndividual->collect(o|thisModule.initNamedIndividualProperties(o))
		)
	do{
		conjProperties;
	}
}

rule initAMNAbstractVariables(rd: SW!RDFDocument) {
	using {
		IEXT: String = 'IEXT';
		ICEXT: String = 'ICEXT';
	}
	to
		abstractVariables: AMN!Variables(
			name <- IEXT,
			name <- ICEXT,
			name <- rd.owlDatatypeProperty->collect(o | thisModule.IEXT_name_Range(o.range.shortName))
		)
	do{
		abstractVariables;	
	}
}

rule initAMNInvariant(rd: SW!RDFDocument, abstractVariables: Sequence(AMN!Variables)) {
	using {
		IEXT: String = 'IEXT';
		ICEXT: String = 'ICEXT';
	}
	to
		inVariant: AMN!Conjunction(
			predicate <- abstractVariables->first().name->collect(o | thisModule.invariantFromAC(o)),
			predicate <- Sequence{icPred2},
			predicate <- rd.owlClass->select(c | 
				c.subClassOf.size() > 0)
				->collect(c|thisModule.initClassHierarchy(c))
		),
		icPred: AMN!AtomicPredicate(
			sign <- ':',
			expression <- Sequence{leftVar, icExp}
		),
		leftVar: AMN!Variable(name <- ICEXT),
		icExp: AMN!AtomicPredicate(
			sign <- '-->',
			expression <- Sequence{icVar, powIR}
		),
		icVar: AMN!Variable(name <- 'IC'),
		irVar: AMN!Variable(name <- 'IR'),
		powIR: AMN!FunctionalExpression(
			sign <- 'POW',
			expression <- irVar	
		),
		icPred2: AMN!AtomicPredicate(
			sign <- '=',
			expression <- Sequence{icThing, ricThing}
		),
		icThing: AMN!FunctionalExpression(
			sign <- ICEXT,
			expression <- icThingVar	
		),
		icThingVar: AMN!Variable(name <- 'Thing'),
		ricThing: AMN!Variable(name <- 'IR')
	do{
		Sequence{inVariant,
			rd.owlObjectProperty->collect(o|thisModule.resolveTemp(o, 'inv_card')),
			rd.owlObjectProperty->select(o|not thisModule.isEnumDatatype(o.shortName))->collect(c|thisModule.resolveTemp(c, 'domain_rel')),
			rd.owlObjectProperty->select(o|not thisModule.isEnumDatatype(o.shortName))->collect(c|thisModule.resolveTemp(c, 'range_rel')),
			SW!Restriction.allInstances()->collect(r | thisModule.ClassRestriction2Invariant(r))
		};
	}
}

rule initAMNInitialisation(rd: SW!RDFDocument) {
	using {
		IEXT: String = 'IEXT';
		ICEXT: String = 'ICEXT';
		properties: Set(SW!Property) = rd.owlDatatypeProperty.union(rd.owlObjectProperty);
	}
	to
		icextInit: AMN!AtomicPredicate(
			sign <- ':=',
			expression <- Sequence{initVar, icextSet}
		),
		initVar: AMN!Variable(
			name <- ICEXT
		),
		icextSet: AMN!SetValue(
			value <- Set{initThing},
			value <- rd.owlClass->collect(c | thisModule.initClass(rd, c))	
		),
		initThing: AMN!AtomicPredicate(
			sign <- '|->',
			expression <- Sequence{lThing, rThing}
		),
		lThing: AMN!StringValue(
			value <- 'Thing'	
		),
		rThing:	AMN!StringValue(
			value <- 'IR'
		)
	do{
		Sequence{
			properties->select(p|not thisModule.isEnumDatatype(p.shortName))->collect(p|thisModule.properties2init(p)),
			icextInit
		};
	}
}

rule Ontology2Predicate {
	from
		ni: SW!Ontology
	to
		ap: AMN!AtomicPredicate(
			sign <- ':',
			expression <- Sequence{lexp, rexp}
		),
		lexp: AMN!NamedConstant(
			name <- ni.shortName
		),
		rexp: AMN!NamedConstant(
			name <- 'IR'	
		)
	do{
		thisModule.debug('Ontology2Predicate');
	}
}

rule NamedIndividual2Predicate {
	from
		c: SW!OWLClass(c.oclIsKindOf(SW!NamedIndividual))
	to
		ap: AMN!AtomicPredicate(
			sign <- ':',
			expression <- Sequence{lexp, rexp}
		),
		lexp: AMN!NamedConstant(
			name <- c.shortName
		),
		rexp: AMN!NamedConstant(
			name <- 'IR'	
		)
	do{
		thisModule.debug(c.oclType());
		thisModule.debug('OWLClass2Predicate:' + c.shortName);
	}
}

rule OWLCLass2Predicate {
	from
		c: SW!OWLClass(not c.oclIsKindOf(SW!NamedIndividual))
	to
		ap: AMN!AtomicPredicate(
			sign <- ':',
			expression <- Sequence{lexp, rexp}
		),
		lexp: AMN!NamedConstant(
			name <- c.shortName
		),
		rexp: AMN!NamedConstant(
			name <- 'IR'	
		)
	do{
		thisModule.debug(c.oclType());
		thisModule.debug('OWLClass2Predicate:' + c.shortName);
	}
}

rule ObjectProperty2Predicate {
	from
		op: SW!ObjectProperty
	to
	-- INVARIANT card --
		inv_card: AMN!AtomicPredicate(
			sign <- '<=',
			expression <- Sequence{leftExp, rightExp}
		),
		leftExp: AMN!FunctionalExpression(
			sign <- 'card',
			expression <- leftIcext
		),
		leftIcext: AMN!FunctionalExpression(
			sign <- 'ICEXT',
			expression <- leftVar
		),
		leftVar: AMN!Variable(
			name <- op.domain.shortName	
		),
		rightExp: AMN!Variable(
			name <- 'NN'	
		),
	-- INVARIANT domain and range
		domain_rel: AMN!AtomicPredicate(
			sign <- '.',
			expression <- thisModule.createDomainRangeInvariant(op.shortName, op.domain.shortName).expression
		),
		range_rel: AMN!AtomicPredicate(
			sign <- '.',
			expression <- thisModule.createDomainRangeInvariant(op.shortName, op.range.shortName).expression
		)
	do{
		thisModule.debug('ObjectProperty2Predicate');
	}
}

rule DatatypeProperty2Predicate {
	from
		dp: SW!DatatypeProperty
	to
	-- SETS range --
		range_set: AMN!SetDecl(
			name <- 'IP_' + dp.range.shortName + '_Range',
			element <- Sequence{dp.shortName}	
		),
	-- ABSTRACT_CONSTANS --
		range_ac: AMN!NamedConstant(
			name <- 'IS_IP_' +	dp.range.shortName + '_Range'
		),
	-- ABSTRACT_VARIABLES --
		range_av: AMN!Variable(
			name <- 'IEXT_' + dp.range.shortName + '_Range'
		)
	do{
		thisModule.debug('DatatypeProperty2Predicate');
	}
}

rule invariantFromAC(variable: String){
	using{

	}
	to
		leftInv: AMN!AtomicPredicate(
			sign <- ':',
			expression <- Sequence{initVar, rightInv}
		),
		initVar: AMN!Variable(
			name <- variable
		),
		rightInv: AMN!AtomicPredicate(
			sign <- '-->',
			expression <- Sequence{rightIP, rightPOW}
		),
		rightIP: AMN!Variable(
			-- name <- thisModule.nameInSETS(variable)
		),
		rightPOW: AMN!FunctionalExpression(
			sign <- 'POW'
			-- expression <- rightMul
		),
		rightMul: AMN!AtomicPredicate(
			sign <- '*',
			expression <- Sequence{mulConst, mulVar}
		),
		mulConst: AMN!NamedConstant(
			name <- 'IR'	
		),
		mulVar: AMN!Variable(
			-- name <- 'IR'
		)
		   
	do{
		if (variable = 'ICEXT') {
			rightIP.name <- 'IC';
			rightPOW.expression <- mulConst;
		}
		else{
			rightIP.name <- variable.regexReplaceAll('IEXT', 'IP');
			rightPOW.expression <- rightMul;
			if (variable = 'IEXT') {
				mulVar.name <- 'IR';
			}
			else{
				mulVar.name <- variable.regexReplaceAll('IEXT_([a-zA-Z]+)_Range', '$1_TYPE').toUpper();
			}
		}
		leftInv;	
	}
}

rule Sparql2Operations{
	from
		sq: SW!SparqlQuery
	using {
		res : String = 'res';
	}
	to 
		op: AMN!Operation(
		name <- 'patientsWithTumorOfStageIIIa', --- TODO: How to get such name?
		outputParams <- res,
		substitution <-block
		),
		block: AMN!Block(
			substitution <- equal
		),
		equal : AMN!BecomesEqual(
			leftExpression <- leftExp,
			rightExpression <- rightExp
		),
		leftExp: AMN!Variable(
			name <- res
		),
		rightExp: AMN!SetComprehension(
			variable <- 'rcrd',
			predicate <- ap
		),
		ap: AMN!Conjunction(
			predicate <- Sequence{stap, estPred}
		),
		stap: AMN!AtomicPredicate(
			sign <- ':',
			expression <- Sequence{stapvar, st}
		),
		stapvar: AMN!Variable(
			name <- 'rcrd'
		),
		st: AMN!StructType(
			element <- sq.select.variables->collect(v | thisModule.selvar2struct(v))
		),
		estPred: AMN!ExistentialPredicate(
			variable <- sq.select.where.patterns->select(p|p.predicate='a')->collect(s|if s.subject.size() < 2 then s.subject + s.subject else s.subject endif),
			predicate <- estConj
		),
		estConj: AMN!Conjunction(
			predicate <- sq.select.where.patterns->collect(p | thisModule.selectWhere2Predicate(sq, p))
		)
}

rule initAMNRefines(ctxt: AMN!AbstractMachine, name: String, rd: SW!RDFDocument){
	to 
		am: AMN!AbstractMachine(
			name <- name + 'AM',
			sees <- ctxt,
			definitions <- refsDef,
			operations <- refsOper
		),
		refsDef: AMN!Definition(
			name <- 'STRING_TYPE',
			type <- 'seq(0..255)'
		),
		refsOper: AMN!Operation(
			name <- 'patientsWithTumorOfStageIIIa',
			outputParams <- 'res',
			substitution <- block
		),
		block: AMN!Block(
			substitution <- any
		),
		any : AMN!Any(
			any <- 'res1',
			where <- anyPred,
			thenPart <- thenEqual
		),
		anyPred: AMN!AtomicPredicate(
			sign <- ':',
			expression <- Sequence{anyExpVar, anyExp}
		),
		anyExpVar: AMN!Variable(
			name <- 'res1'
		),
		anyExp: AMN!FunctionalExpression(
			sign <- 'POW',
			expression <- anySt
		),
		anySt: AMN!StructType(
			element <- anyStT
		),
		anyStT: AMN!StructTypeElement(
			name <- 'name',
			type <- anyStTVar
		),
		anyStTVar: AMN!Variable(
			name <- 'STRING_TYPE'	
		),
		thenEqual: AMN!BecomesEqual(
			leftExpression <- thenLeftExp,
			rightExpression <- thenRightExp
		),
		thenLeftExp: AMN!Variable(
			name <- 'res'
		),
		thenRightExp: AMN!Variable(
			name <- 'res1'
		)
	do{
		thisModule.debug('ctxt name:');
		thisModule.debug(ctxt.name);
		
		-- init NamedIndividual
		for(n in rd.owlNamedIndividual){
			thisModule.gNamedIndividual <- thisModule.gNamedIndividual->including(n.shortName);
		}
		-- init class with property
		for(class in rd.owlClass) {
			for(subClass in class.subClassOf){
				if(not subClass.shortName.oclIsUndefined()){
					thisModule.gParentClass <-
						thisModule.gParentClass->including(class.shortName, subClass.shortName);
				}
				for (restr in subClass.owlRestriction) {
					if(thisModule.gClassRestriction->get(restr.onProperty.shortName).oclIsUndefined()){
						thisModule.gClassRestriction <- 
							thisModule.gClassRestriction->including(
								restr.onProperty.shortName,
								OrderedSet{restr.allValuesFrom.shortName}
							);
					}
					else{
						thisModule.gClassRestriction <- 
							thisModule.gClassRestriction->including(
								restr.onProperty.shortName,
								thisModule.gClassRestriction->get(restr.onProperty.shortName)->append(restr.allValuesFrom.shortName)
							);
					}
				}
			}
		}
		thisModule.debug('gClassRestriction: ' + thisModule.gClassRestriction);
		thisModule.debug('gParentClass: ' + thisModule.gParentClass);
		am;
	}
}

rule properties2init(p: SW!Property){
	using{

		ac:String = if p.range.oclIsUndefined() then p.shortName else p.range.shortName endif;	
	}
	to
		icextInit: AMN!AtomicPredicate(
			sign <- ':=',
			expression <- Sequence{initVar, icextSet}
		),
		initVar: AMN!Variable(
		),
		icextSet: AMN!SetValue(
			value <- Set{initThing}
		),
		initThing: AMN!AtomicPredicate(
			sign <- '|->',
			expression <- Sequence{lThing, rThing}
		),
		lThing: AMN!StringValue(
			value <- p.shortName	
		),
		rThing:	AMN!StringValue(
			value <- '{}'
		)
	do{
		if (thisModule.isBuiltinDatatype(p.range.shortName)) {
			-- built-in datatype
			ac <- thisModule.IEXT_name_Range(ac);
		}
		else {
			-- non built-in datatype
			ac <- 'IEXT';
		}
		initVar.name <- ac;
		icextInit;	
	}
}

lazy rule ClassRestriction2Invariant{
	from r: SW!Restriction
	using {
		diseaseStage: String = r.allValuesFrom.shortName;
		disease: String = diseaseStage.regexReplaceAll('Stage', '');
		iextName: String = '';
		ipName: String = '';
	}
	to
		ap: AMN!AtomicPredicate(
			sign <- '.',
			expression <- Sequence{nXY,rightExpBrac}
		),
		nXY: AMN!UnaryOperator(
			sign <- '!',
			expression <- axy
		),
		axy: AMN!BinaryOperator(
			sign <- ',',
			expression <- Sequence{xv, yv}
		),
		xv: AMN!Variable(
			name <- 'xx'	
		),
		yv: AMN!Variable(
			name <- 'yy'	
		),
		rightExpBrac: AMN!Bracketed(
			predicate <- rightExp
		),
		rightExp: AMN!Conjunction(
			predicate <- Sequence{rxr, ryr, r3456}	
		),
		rxr: AMN!BinaryOperator(
			sign <- ':',
			expression <- Sequence{rxx, rxir}
		),
		rxx: AMN!Variable(
			name <- 'xx'
		),
		rxir: AMN!Variable(
			name <- 'IR'
		),
		ryr: AMN!AtomicPredicate(
			sign <- ':',
			expression <- Sequence{ryy, ryir}
		),
		ryy: AMN!Variable(
			name <- 'yy'
		),
		ryir: AMN!Variable(
			name <- 'IR'	
		),
		r3456: AMN!AtomicPredicate(
			sign <- '=>',
			expression <- Sequence{r34, r56}
		),
		r34: AMN!AtomicPredicate(
			sign <- ':',
			expression <- Sequence{r3xxyy, r4iext}
		),
		r3xxyy: AMN!BinaryOperator(
			sign <- '|->',
			expression <- Sequence{r3xx, r3yy}
		),
		r3xx: AMN!Variable(
			name <- 'xx'	
		),
		r3yy: AMN!Variable(
			name <- 'yy'	
		),
		r4iext: AMN!FunctionalExpression(
			sign <- 'IEXT',
			expression <- r4dn
		),
		r4dn: AMN!Variable(
			name <- r.onProperty.shortName
		),
		r56: AMN!AtomicPredicate(
			sign <- ':',
			expression <- Sequence{r5xx, r6icext}
		),
		r5xx: AMN!Variable(
			name <- 'xx'	
		),
		r6icext: AMN!FunctionalExpression(
			sign <- 'ICEXT',
			expression <- r6dn
		),
		r6dn: AMN!Variable(
			name <- diseaseStage
		)
}



lazy rule selvar2struct{
	from s: SW!Variable
	to
		ste: AMN!StructTypeElement(
			name <- s.name,
			type <- t
		),
		t: AMN!NamedConstant(
			name <- 'STRING_TYPE'	
		)
}

rule selectWhere2Predicate(s: SW!SparqlQuery, pattern: SW!TriplePattern){
	using {
		selNames: Set(SW!Variable) = s.select.variables->collect(v|v.name);
		estVars: Set(String) = s.select.where.patterns->select(p|p.predicate='a')->collect(s|s.subject);
		subject:String = if pattern.subject.size() < 2 then pattern.subject + pattern.subject else pattern.subject endif;
		predicate:String = pattern.predicate;
	}
	to 
		ap: AMN!AtomicPredicate(
			sign <- ':'
			-- expression <- Sequence{leftExp, rightExp}
		),
		-- pp: ICEXT(Patient)
		leftExp: AMN!Variable(
			name <- subject
		),
		rightExp: AMN!FunctionalExpression(
			sign <- 'ICEXT',
			expression <- rightVar
		),
		rightVar: AMN!Variable(
			name <- pattern.object	
		),
		-- (pp |-> rcrd'name): IEXT_String_Range(hasName)
		-- from select
		
		leftExp1Bracket: AMN!Bracketed(
			predicate <- leftExp1
		),
		leftExp1: AMN!AtomicPredicate(
			sign <- '|->',
			expression <- Sequence{leftExp1Var, leftExp1Name}
		),
		leftExp1Var: AMN!Variable(
			name <- subject	
		),
		leftExp1Name: AMN!Variable(
			name <- 'rcrd\'' + 	pattern.object
		),
		rightExp1: AMN!FunctionalExpression(
			sign <- 'IEXT_string_Range',
			expression <- rightExp1Var
		),
		rightExp1Var: AMN!Variable(
			name <- pattern.predicate	
		),
		-- (pp |-> tumor): IEXT(hasNeoplasm)
		leftExp2Bracket: AMN!Bracketed(
			predicate <- leftExp2
		),
		leftExp2: AMN!AtomicPredicate(
			sign <- '|->',
			expression <- Sequence{leftExp2Var1, leftExp2Var2}
		), 
		leftExp2Var1: AMN!Variable(
			name <- subject
		),
		leftExp2Var2: AMN!Variable(
			name <- pattern.object	
		),
		rightExp2: AMN!FunctionalExpression(
			sign <- 'IEXT',
			expression <- rightExp2Var
		),
		rightExp2Var: AMN!Variable(
			name <- pattern.predicate	
		),
		--(tumor |-> stageIIIa): IEXT_CancerStage_Range(hasStage)
		-- (tumor : ICEXT(NeoplasmStage) & NSCLC_stage_IIIa : ICEXT(NeoplasmStage))
		leftExp3Bracket: AMN!Bracketed(
			predicate <- leftExp3And
		),
		leftExp3And: AMN!AtomicPredicate(
			sign <- '&',
			expression <- Sequence{leftExp3, rightExp3}
		),
		leftExp3: AMN!AtomicPredicate(
			sign <- ':',
			expression <- Sequence{leftExp3Var1, leftExp3Var2}
		), 
		leftExp3Var1: AMN!Variable(
			name <- subject
		),
		leftExp3Var2: AMN!FunctionalExpression(
			sign <- 'ICEXT',
			expression <- leftExp3Var2Fv
		),
		leftExp3Var2Fv: AMN!StringValue(
			value <- if thisModule.gClassRestriction.get(pattern.predicate).oclIsUndefined() 
					then '' 
					else thisModule.gParentClass.get(thisModule.gClassRestriction.get(pattern.predicate).first()) endif
		),
		rightExp3: AMN!AtomicPredicate(
			sign <- ':',
			expression <- Sequence{rightExp3Var1, rightExp3Var2}
		), 
		rightExp3Var1: AMN!Variable(
			name <- pattern.object
		),
		rightExp3Var2: AMN!FunctionalExpression(
			sign <- 'ICEXT',
			expression <- rightExp3Var2Fv
		),
		rightExp3Var2Fv: AMN!StringValue(
			value <- if thisModule.gClassRestriction.get(pattern.predicate).oclIsUndefined() 
					then '' 
					else thisModule.gParentClass.get(thisModule.gClassRestriction.get(pattern.predicate).first()) endif
		)
	do{
		if (pattern.predicate = 'a') {
			ap.expression <- Sequence{leftExp, rightExp};
			ap;
		}
		else{
			if (selNames->includes(pattern.object)){
				ap.expression <- Sequence{leftExp1Bracket, rightExp1};
				ap;
			}
			else{
				if (thisModule.isEnumDatatype(pattern.predicate)) {
					leftExp3Bracket;
				}
				else{
					ap.expression <- Sequence{leftExp2Bracket, rightExp2};	
					ap;
				}
			}
		}
		
	}
}

--- Init Class
rule initClass(rd:SW!RDFDocument, c:SW!Class) {
	using {
		values: Set(String) = Set{};	
	}
	to
		ap: AMN!AtomicPredicate(
			sign <- '|->',
			expression <- Sequence{leftExp, rightExp}
		),
		leftExp: AMN!StringValue(
			value <- c.shortName	
		),
		rightExp: AMN!SetValue(
				
		)
	do{
		for(n in rd.owlNamedIndividual){
			if(c.shortName=n.type.shortName or c.shortName=thisModule.gParentClass.get(n.type.shortName)){
				values <- values->including(n.shortName); 
			}
		}
		rightExp.value <- values->collect(v|thisModule.InitClassSetVal(v));
		ap;	
	}
}

rule InitClassSetVal(n: String) {
	to 
		s: AMN!StringValue(
			value <- n	
		)
	do{
		s;	
	}
}

--- Init the SubClassOf of Classes
lazy rule initClassHierarchy{
	from c: SW!Class
	to
		ap: AMN!AtomicPredicate(
			sign <- '<:',
			expression <- Sequence{leftExp, rightExp}
		),
		leftExp: AMN!FunctionalExpression(
			sign <- 'ICEXT',
			expression <- Sequence{leftVar}
		),
		leftVar: AMN!StringValue(
			value <- c.subClassOf->collect(s|s.shortName).first()
		),
		rightExp: AMN!FunctionalExpression(
			sign <- 'ICEXT',
			expression <- Sequence{rightVar}
		),
		rightVar: AMN!StringValue(
			value <- c.shortName
		)
}

--- Init ObjectProperty
lazy rule ObjectProperties2Set{
	from rd: sw!RDFDocument
	using {
		setName: String = 'IP';
	}
	to
		--- SETS
		initSet: AMN!SetDecl(
			name <- 'IP',
			element <- rd.owlObjectProperty->collect(o|o.shortName)	
		)
}

rule initPropertiesIRI(abstractConstant:String) {
	using {
		acSetName: String = abstractConstant.substring(4, abstractConstant.size());
	}
	to	
		isipIRI: AMN!AtomicPredicate(
			sign <- ':',
			expression <- Sequence{isipIRIVar, iriPred}
		),
		isipIRIVar: AMN!NamedConstant(
			name <- abstractConstant
		),
		iriPred: AMN!AtomicPredicate(
			sign <- '+->',
			expression <- Sequence{iriLeftVar, iriRightVar}
		),
		iriLeftVar: AMN!NamedConstant(
			name <- 'IRI'	
		),
		iriRightVar: AMN!NamedConstant(
			name <- acSetName
		)
	do {
		isipIRI;
	}
}

rule initPropertiesFIN(abstractConstant:String) {
	to	
		isipFIN: AMN!AtomicPredicate(
			sign <- ':',
			expression <- Sequence{isipFINVar, finPred}	
		),
		isipFINVar: AMN!NamedConstant(
			name <- abstractConstant
		),
		finPred: AMN!FunctionalExpression(
			sign <- 'FIN',
			expression <- finVar
		),
		finVar: AMN!NamedConstant(
			name <- abstractConstant
		)
	do {
		isipFIN;
	}
}

rule initPropertiesDOM(abstractConstants:Sequence(String)) {
	using {
		ac: String = abstractConstants->first();
	}
	to	
		iri: AMN!AtomicPredicate(
			sign <- '=',
			expression <- Sequence{iriConst, domBin} 
		),
		iriConst: AMN!NamedConstant(
			name <- 'IRI'
		),
		domBin: AMN!BinaryOperator(
			sign <- '\\/',
			noBracket <- true,
			expression <- thisModule.initPropertiesDOMFunc('IS_IR'),
			expression <- abstractConstants->collect(c|thisModule.initPropertiesDOMFunc(c))
		)
	do {
		iri;
	}
}

rule initPropertiesDOMFunc(ac: String) {
	to
		domFunc: AMN!FunctionalExpression(
			sign <- 'dom',
			expression <- domConst
		),
		domConst: AMN!NamedConstant(
			name <- ac	
		)
	do {
		domFunc;	
	}
}

rule initPropertiesCardDOM(abstractConstants:Sequence(String)) {
	using {
		ac: String = abstractConstants->first();
	}
	to	
		iri: AMN!AtomicPredicate(
			sign <- '=',
			expression <- Sequence{iriCard, domBin} 
		),
		iriCard: AMN!FunctionalExpression(
			sign <- 'card',
			expression <- iriConst
		),
		iriConst: AMN!NamedConstant(
			name <- 'IRI'
		),
		domBin: AMN!BinaryOperator(
			sign <- '+',
			noBracket <- true,
			expression <- thisModule.initPropertiesCardDOMFunc('IS_IR'),
			expression <- abstractConstants->collect(c|thisModule.initPropertiesCardDOMFunc(c))
		)
	do {
		iri;
	}
}

rule initPropertiesCardDOMFunc(ac: String) {
	to
		cardFunc: AMN!FunctionalExpression(
			sign <- 'card',
			expression <- domFunc
		),
		domFunc: AMN!FunctionalExpression(
			sign <- 'dom',
			expression <- domConst
		),
		domConst: AMN!NamedConstant(
			name <- ac	
		)
	do {
		cardFunc;	
	}
}

-- !(xx, yy).(xx: IR & yy: IR & (xx|->yy):IEXT(hasNeoplasm) =>
--        xx: ICEXT(Patient) ) &
rule createDomainRangeInvariant(propertyName: String, target: String){
	to
		ap: AMN!AtomicPredicate(
			sign <- '.',
			expression <- Sequence{nXY,rightExpBrac}
		),
		nXY: AMN!UnaryOperator(
			sign <- '!',
			expression <- axy
		),
		axy: AMN!BinaryOperator(
			sign <- ',',
			expression <- Sequence{xv, yv}
		),
		xv: AMN!Variable(
			name <- 'xx'	
		),
		yv: AMN!Variable(
			name <- 'yy'	
		),
		rightT: AMN!Variable(
			name <- 'right'
		),
		rightExpBrac: AMN!Bracketed(
			predicate <- rightExp
		),
		rightExp: AMN!Conjunction(
			predicate <- Sequence{rxr, ryr, r3456}	
		),
		rxr: AMN!BinaryOperator(
			sign <- ':',
			expression <- Sequence{rxx, rxir}
		),
		rxx: AMN!Variable(
			name <- 'xx'
		),
		rxir: AMN!Variable(
			name <- 'IR'
		),
		ryr: AMN!AtomicPredicate(
			sign <- ':',
			expression <- Sequence{ryy, ryir}
		),
		ryy: AMN!Variable(
			name <- 'yy'
		),
		ryir: AMN!Variable(
			name <- 'IR'	
		),
		r3456: AMN!AtomicPredicate(
			sign <- '=>',
			expression <- Sequence{r34, r56}
		),
		r34: AMN!AtomicPredicate(
			sign <- ':',
			expression <- Sequence{r3xxyy, r4iext}
		),
		r3xxyy: AMN!BinaryOperator(
			sign <- '|->',
			expression <- Sequence{r3xx, r3yy}
		),
		r3xx: AMN!Variable(
			name <- 'xx'	
		),
		r3yy: AMN!Variable(
			name <- 'yy'	
		),
		r4iext: AMN!FunctionalExpression(
			sign <- 'IEXT',
			expression <- r4dn
		),
		r4dn: AMN!Variable(
			name <- propertyName
		),
		r56: AMN!AtomicPredicate(
			sign <- ':',
			expression <- Sequence{r5xx, r6icext}
		),
		r5xx: AMN!Variable(
			name <- 'xx'	
		),
		r6icext: AMN!FunctionalExpression(
			sign <- 'ICEXT',
			expression <- r6dn
		),
		r6dn: AMN!Variable(
			name <- target	
		)
	do{
		ap;	
	}
}

lazy rule initNamedIndividualProperties{
	from o: SW!NamedIndividual
	to
		am: AMN!AtomicPredicate(
			sign <- ':',
			expression <- Sequence{lexp, rexp}
		),
		lexp: AMN!NamedConstant(
			name <- o.shortName
		),
		rexp: AMN!NamedConstant(
			name <- 'IR'	
		)
	
}

helper def: ISIP_name_Range(name: String): String = 
	'IS_IP_' +	name + '_Range'
;

helper def: IEXT_name_Range(name: String): String = 
	'IEXT_' +	name + '_Range'
;

helper def: refinementName(name: String): String = 
	name.substring(1,1).toUpper() + name.substring(2,name.size())
;

helper def: isBuiltinDatatype(t: String): Boolean =
	let builtinTypes: Set(String) = Set{'string', 'real', 'bool'} in
	if builtinTypes.includes(t) then
		true
	else
		false
	endif
; 

helper def: isEnumDatatype(t: String): Boolean =
	if thisModule.gClassRestriction->get(t).oclIsUndefined() then
		false
	else
		true
	endif
; 

helper def: isInstance(n: String): Boolean = 
	if thisModule.gNamedIndividual->includes(n) then
		true
	else
		false
	endif
;
