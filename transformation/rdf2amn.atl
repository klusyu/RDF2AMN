module rdf2amn;
create OUT: AMN from IN: SW;

-- @path SW=/metamodel/SW.ecore
-- @path AMN=/metalmodel/AMN.ecore


rule RDF2Refinement{
	from 
		rd: SW!RDFDocument
	using {
		sos : Set(AMN!Operation) = Set{};
		avs: String = 'ICEXT';
		objectProperties: Set(SW!ObjectProperty) = rd.owlObjectProperty;
		datatypeProperties: Set(SW!DatatypeProperty) = rd.owlDatatypeProperty;
	}
	to 
		
		ref: AMN!Refinement(
			name <- rd.owlOntology->collect(c|c.shortName),
			refines <- am,
			sees <- ctxt,
			sets <- classSet,
			sets <- rd.owlDatatypeProperty->collect(o | thisModule.initPropertySet(o)),
			sets <- rd.owlObjectProperty->collect(o | thisModule.initPropertySet(o)),
			abstractVariables <- Set{avs},
			abstractConstants <- 'IS_IP',
			abstractConstants <- rd.owlDatatypeProperty->collect(o | thisModule.initPropertyAbstractConstans(o).name)->select(o|o.size() > 0),
			abstractConstants <- rd.owlObjectProperty->collect(o | thisModule.initPropertyAbstractConstans(o).name)->select(o|o.size() > 0),
			properties <- conjProperties,
			invariant <- Sequence{inVariant},
			invariant <- rd.owlDatatypeProperty->collect(o | thisModule.initPropertyInvariant(o))->select(o|o.sign.size()>0),
			invariant <- rd.owlObjectProperty->collect(o | thisModule.initPropertyInvariant(o))->select(o|o.sign.size()>0),
			initialization <- icextInit
			
		),
		--- SEES
		ctxt: AMN!AbstractMachine(
			name <- 'ContextRDF'
		),
		--- REFINES
		am: AMN!AbstractMachine(
			name <- 'Hospital'
		),
		--- SETS
		classSet: AMN!SetDecl(
			name <- 'IC',
			element <- rd.owlClass->collect(c|c.shortName)
		),
		--- PROPERTIES
		conjProperties: AMN!Conjunction(
			predicate <- isipIRI,
			predicate <- isipFIN
		),
		isipIRI: AMN!AtomicPredicate(
			sign <- ':',
			expression <- Sequence{isipIRIVar, iriPred}
		),
		isipIRIVar: AMN!NamedConstant(
			name <- 'IS_IP'	
		),
		isipFIN: AMN!AtomicPredicate(
			sign <- ':',
			expression <- Sequence{isipFINVar, finPred}	
		),
		isipFINVar: AMN!NamedConstant(
			name <- 'IS_IP'	
		),
		iriPred: AMN!AtomicPredicate(
			sign <- '+->',
			expression <- Sequence{iriLeftVar, iriRightVar}
		),
		iriLeftVar: AMN!NamedConstant(
			name <- 'IRI'	
		),
		iriRightVar: AMN!NamedConstant(
			name <- 'IS_IP'	
		),
		finPred: AMN!FunctionalExpression(
			sign <- 'FIN',
			expression <- finVar
		),
		finVar: AMN!NamedConstant(
			name <- 'IS_IP'	
		),
		--- INVARIANT
		inVariant: AMN!Conjunction(
			predicate <- Sequence{icPred, icPred2},
			predicate <- rd.owlClass->select(c | 
				not c.subClassOf.oclIsUndefined())
				->collect(c|thisModule.initClassHierarchy(c))
		),
		icPred: AMN!AtomicPredicate(
			sign <- ':',
			expression <- Sequence{leftVar, icExp}
		),
		leftVar: AMN!Variable(name <- avs),
		icExp: AMN!AtomicPredicate(
			sign <- '->',
			expression <- Sequence{icVar, powIR}
		),
		icVar: AMN!Variable(name <- 'IC'),
		irVar: AMN!Variable(name <- 'IR'),
		powIR: AMN!FunctionalExpression(
			sign <- 'POW',
			expression <- irVar	
		),
		icPred2: AMN!AtomicPredicate(
			sign <- '=',
			expression <- Sequence{icThing, ricThing}
		),
		icThing: AMN!FunctionalExpression(
			sign <- avs,
			expression <- icThingVar	
		),
		icThingVar: AMN!Variable(name <- 'Thing'),
		ricThing: AMN!Variable(name <- 'IR'),
		-- Properties INVARIANT
		
		--- Initialization
		icextInit: AMN!AtomicPredicate(
			sign <- ':=',
			expression <- Sequence{initVar, icextSet}
		),
		initVar: AMN!Variable(
			name <- avs	
		),
		icextSet: AMN!SetValue(
			value <- Set{initThing},
			value <- rd.owlClass->collect(c | thisModule.initClass(c))	
		),
		initThing: AMN!AtomicPredicate(
			sign <- '|->',
			expression <- Sequence{lThing, rThing}
		),
		lThing: AMN!StringValue(
			value <- 'Thing'	
		),
		rThing:	AMN!StringValue(
			value <- 'IR'
		)
		
	do {
		thisModule.debug('RDF2Refinement');	
	}
}

--- Init Class
lazy rule initClass {
	from c: SW!Class
	to
		ap: AMN!AtomicPredicate(
			sign <- '|->',
			expression <- Sequence{leftExp, rightExp}
		),
		leftExp: AMN!StringValue(
			value <- c.shortName	
		),
		rightExp: AMN!StringValue(
			value <- '{ }'	
		)
}

--- Init the SubClassOf of Classes
lazy rule initClassHierarchy{
	from c: SW!Class
	to
		ap: AMN!AtomicPredicate(
			sign <- '<:',
			expression <- Sequence{leftExp, rightExp}
		),
		leftExp: AMN!FunctionalExpression(
			sign <- 'ICEXT',
			expression <- Sequence{leftVar}
		),
		leftVar: AMN!StringValue(
			value <- c.subClassOf.shortName	
		),
		rightExp: AMN!FunctionalExpression(
			sign <- 'ICEXT',
			expression <- Sequence{rightVar}
		),
		rightVar: AMN!StringValue(
			value <- c.shortName
		)
}

--- Init ObjectProperty and DatatypeProperty
lazy rule initPropertySet{
	from o: SW!Property
	using {
		range: SW!Class = o.range;
		domain: SW!Class = o.domain;
		setName: String = 'IP';
	}
	to
		--- SETS
		initSet: AMN!SetDecl(
			element <- Sequence{o.shortName}	
		)
	do {
		thisModule.debug('initProperty');
		--- set SETS
		if (range.oclIsUndefined()) {
			-- enumeration datatype
			initSet.name <- 'IP_' + o.shortName + '_Range';
		}
		else{
			thisModule.debug('range:' + range.shortName);
			if (thisModule.isBuiltinDatatype(range.shortName)) {
				-- built-in datatype
				initSet.name <- 'IP_' + range.shortName + '_Range';
			}
			else {
				-- non built-in datatype
				initSet.name <- 'IP';
			}
			thisModule.debug('initSet.name:' + initSet.name);
		}
	}
}

lazy rule initPropertyAbstractConstans{
	from o: SW!Property
	using {
		range: SW!Class = o.range;
		domain: SW!Class = o.domain;
		setName: String = 'IP';
	}
	to
		namedConstant: AMN!Variable(
			name <- ''
		)
	do{
		if (range.oclIsUndefined()) {
			-- enumeration datatype
			namedConstant.name <- 'IL_' + o.shortName;
		}
	}
}

lazy rule initPropertyInvariant{
	from o: SW!Property
	using {
		range: SW!Class = o.range;
		domain: SW!Class = o.domain;
		iextName: String = '';
		ipName: String = '';
	}
	to
		ap: AMN!AtomicPredicate(
			expression <- Sequence{leftExp, rightExp}
		),
		leftExp: AMN!Variable(),
		rightExp: AMN!AtomicPredicate(
			sign <- '->',
			expression <- Sequence{ipLeft, ipRight}
		),
		ipLeft: AMN!Variable(),
		ipRight: AMN!FunctionalExpression(
			sign <- 'POW',
			expression <- ipExp
		),
		ipExp: AMN!AtomicPredicate(
			sign <- '*',
			expression <- Sequence{ipConst, strConst}
		),
		ipConst: AMN!NamedConstant(
			name <- 'IP'
		),
		strConst: AMN!NamedConstant(
		)
	do {
		if (range.oclIsUndefined()) {
			-- enumeration datatype
			leftExp.name <- 'IEXT_' + o.shortName + '_Range';
			ipLeft.name <- 'IP_' + o.shortName + '_Range';
			strConst.name <- o.shortName;
			ap.sign <- ':';
		}
		else{
			thisModule.debug('range:' + range.shortName);
			if (thisModule.isBuiltinDatatype(range.shortName)) {
				-- built-in datatype
				leftExp.name <- 'IEXT_' + range.shortName + '_Range';
				ipLeft.name <- 'IP_' + range.shortName + '_Range';
				strConst.name <- 'STRING_TYPE';
				ap.sign <- ':';
			}
			else {
				-- non built-in datatype
				leftExp.name <- '_nonBuiltinIEXT';
				ipLeft.name <- '_nonBuiltinIP';
				ap.sign <- '';
				thisModule.debug('----------ERROR------');
			}
		}
	}
}

helper def: isBuiltinDatatype(t: String): Boolean =
	let builtinTypes: Set(String) = Set{'string', 'real', 'bool'} in
	if builtinTypes.includes(t) then
		true
	else
		false
	endif
; 

	
rule createPred2Variables(s: String, leftVar: String, rightVar: String) {
	to 
		ap: AMN!AtomicPredicate(
			sign <- s,
			expression <- Sequence{leftExp, rightExp}
		),
		leftExp: AMN!Variable(
			name <- leftVar
		),
		rightExp: AMN!Variable(
			name <- rightVar
		)
	do {
		thisModule.debug('createPred2Variables');
	}
}

rule createVariablePredicate(s: String, leftVar: String, pred: AMN!Predicate) {
	to ap: AMN!AtomicPredicate(
		sign <- s,
		expression <- Sequence{leftExp, pred}
	),
	leftExp: AMN!Variable(
		name <- leftVar
	)
}

rule createFunctionalPredicate(s: String, var: String) {
	to fp: AMN!FunctionalPredicate(
		sign <- s,
		expression <- e	
	),
	e: AMN!Varaible(
		name <- var	
	)
}